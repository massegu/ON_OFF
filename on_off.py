# -*- coding: utf-8 -*-
"""ON_OFF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UPfjnMj3HBaTudcmr-AA1W9CldIChQA6
"""

import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets

# Generador de est√≠mulos
def generar_estimulo(tipo):
    matriz = np.zeros((5,5))
    if tipo == "centro_brillante":
        matriz[2,2] = 1
    elif tipo == "centro_oscuro":
        matriz = np.ones((5,5))
        matriz[2,2] = 0
    elif tipo == "periferia_brillante":
        matriz = np.ones((5,5))
        matriz[2,2] = 0
    elif tipo == "periferia_oscura":
        matriz = np.zeros((5,5))
        matriz[2,2] = 1
    elif tipo == "uniforme_brillante":
        matriz = np.ones((5,5))
    elif tipo == "uniforme_oscuro":
        matriz = np.zeros((5,5))
    return matriz

# Modelos de respuesta
def respuesta_bipolar(matriz, tipo):
    centro = matriz[2,2]
    return centro if tipo == "ON" else 1 - centro

def respuesta_ganglionar(matriz, tipo):
    centro = matriz[2,2]
    periferia = np.mean(np.delete(matriz.flatten(), 12))
    return centro - periferia if tipo == "ON" else periferia - centro

# Campo receptivo esquem√°tico
def generar_campo_receptivo(tipo_celula):
    receptivo = np.zeros((5,5))
    centro = (2,2)
    for i in range(5):
        for j in range(5):
            if (i,j) == centro:
                receptivo[i,j] = 1 if tipo_celula == "ON" else -1
            else:
                receptivo[i,j] = -1 if tipo_celula == "ON" else 1
    return receptivo

# Visualizaci√≥n completa
def visualizar_completo(tipo):
    matriz = generar_estimulo(tipo)
    respuestas = {
        "Bipolar ON": respuesta_bipolar(matriz, "ON"),
        "Bipolar OFF": respuesta_bipolar(matriz, "OFF"),
        "Ganglionar ON": respuesta_ganglionar(matriz, "ON"),
        "Ganglionar OFF": respuesta_ganglionar(matriz, "OFF")
    }

    fig, axs = plt.subplots(1, 3, figsize=(18,5))

    # Est√≠mulo visual
    axs[0].imshow(matriz, cmap='gray', interpolation='nearest')
    axs[0].set_title(f"üñº Est√≠mulo aplicado: {tipo.replace('_',' ')}")
    axs[0].axis('off')

    # Respuesta celular
    axs[1].bar(respuestas.keys(), respuestas.values(), color=['skyblue','salmon','limegreen','orange'])
    axs[1].set_title("üìä Activaci√≥n de c√©lulas visuales")
    axs[1].set_ylabel("Nivel de activaci√≥n")
    axs[1].set_ylim(-1,1)
    axs[1].grid(True)

    # Campo receptivo ganglionar ON
    receptivo = generar_campo_receptivo("ON")
    im = axs[2].imshow(receptivo, cmap='bwr', vmin=-1, vmax=1)
    axs[2].set_title("üß† Campo receptivo ganglionar ON\nCentro (rojo) vs Periferia (azul)")
    axs[2].axis('off')
    fig.colorbar(im, ax=axs[2], orientation='vertical', label='Activaci√≥n relativa')

    plt.tight_layout()
    plt.show()

# Widget interactivo
selector = widgets.Dropdown(
    options=["centro_brillante", "centro_oscuro", "periferia_brillante", "periferia_oscura", "uniforme_brillante", "uniforme_oscuro"],
    description='Est√≠mulo:',
)

widgets.interact(visualizar_completo, tipo=selector)

"""### üß† Tipos de c√©lulas y su funci√≥n

- **C√©lula bipolar ON**  
  Se activa cuando hay luz en el centro del campo receptivo. Detecta incrementos de luminancia.

- **C√©lula bipolar OFF**  
  Se activa cuando hay oscuridad en el centro. Detecta decrementos de luminancia.

- **C√©lula ganglionar ON (Centro ON - Periferia OFF)**  
  Se activa cuando el centro est√° iluminado y la periferia oscura. Detecta bordes brillantes.

- **C√©lula ganglionar OFF (Centro OFF - Periferia ON)**  
  Se activa cuando el centro est√° oscuro y la periferia iluminada. Detecta bordes oscuros.

üîç Estas c√©lulas trabajan en conjunto para detectar **contrastes locales**, **bordes**, y **transiciones de luz**, fundamentales para la percepci√≥n visual.

üß† Versi√≥n 1: Campo receptivo din√°mico seg√∫n el est√≠mulo

Esta versi√≥n ajusta el esquema del campo receptivo seg√∫n cu√°l de las c√©lulas ganglionares (ON u OFF) responde m√°s al est√≠mulo aplicado.
"""

def visualizar_dinamico(tipo):
    matriz = generar_estimulo(tipo)
    respuestas = {
        "Bipolar ON": respuesta_bipolar(matriz, "ON"),
        "Bipolar OFF": respuesta_bipolar(matriz, "OFF"),
        "Ganglionar ON": respuesta_ganglionar(matriz, "ON"),
        "Ganglionar OFF": respuesta_ganglionar(matriz, "OFF")
    }

    tipo_dominante = "ON" if respuestas["Ganglionar ON"] >= respuestas["Ganglionar OFF"] else "OFF"

    fig, axs = plt.subplots(1, 3, figsize=(18,5))

    axs[0].imshow(matriz, cmap='gray')
    axs[0].set_title(f"Est√≠mulo: {tipo.replace('_',' ')}")
    axs[0].axis('off')

    axs[1].bar(respuestas.keys(), respuestas.values(), color=['skyblue','salmon','limegreen','orange'])
    axs[1].set_title("Activaci√≥n celular")
    axs[1].set_ylim(-1,1)
    axs[1].grid(True)

    receptivo = generar_campo_receptivo(tipo_dominante)
    im = axs[2].imshow(receptivo, cmap='bwr', vmin=-1, vmax=1)
    axs[2].set_title(f"Campo receptivo ganglionar {tipo_dominante}")
    axs[2].axis('off')
    fig.colorbar(im, ax=axs[2], orientation='vertical')

    plt.tight_layout()
    plt.show()

widgets.interact(visualizar_dinamico, tipo=selector)

import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import clear_output

# Imagen sint√©tica: borde horizontal
imagen = np.zeros((10,10))
imagen[5:] = 1  # mitad inferior brillante

# Widget para seleccionar centro
centro_selector = widgets.SelectMultiple(
    options=[(f"{i},{j}", (i,j)) for i in range(5) for j in range(5)],
    description="Centro:",
    rows=5
)

# Widget para seleccionar periferia
periferia_selector = widgets.SelectMultiple(
    options=[(f"{i},{j}", (i,j)) for i in range(5) for j in range(5)],
    description="Periferia:",
    rows=5
)

# Funci√≥n para construir campo receptivo
def construir_campo(centro, periferia):
    campo = np.zeros((5,5))
    for i,j in centro:
        campo[i,j] = 1
    for i,j in periferia:
        campo[i,j] = -1
    return campo

# Aplicar campo como filtro convolucional
def aplicar_filtro(imagen, filtro):
    from scipy.signal import convolve2d
    return convolve2d(imagen, filtro, mode='valid')

# Visualizaci√≥n
def actualizar(centro, periferia):
    clear_output(wait=True)
    campo = construir_campo(centro, periferia)
    activacion = aplicar_filtro(imagen, campo)

    fig, axs = plt.subplots(1, 3, figsize=(18,5))

    axs[0].imshow(campo, cmap='bwr', vmin=-1, vmax=1)
    axs[0].set_title("Campo receptivo definido")
    axs[0].axis('off')
    fig.colorbar(axs[0].imshow(campo, cmap='bwr', vmin=-1, vmax=1), ax=axs[0])

    axs[1].imshow(imagen, cmap='gray')
    axs[1].set_title("Est√≠mulo visual (borde horizontal)")
    axs[1].axis('off')

    axs[2].imshow(activacion, cmap='viridis')
    axs[2].set_title("Activaci√≥n por convoluci√≥n")
    axs[2].axis('off')
    fig.colorbar(axs[2].imshow(activacion, cmap='viridis'), ax=axs[2])

    plt.tight_layout()
    plt.show()

widgets.interact(
    actualizar,
    centro=centro_selector,
    periferia=periferia_selector
)

"""### üß† Ejercicio: dise√±o de campo receptivo

1. Selecciona las posiciones que funcionar√°n como **centro** (activadoras).
2. Selecciona las posiciones que funcionar√°n como **periferia** (inhibidoras).
3. Observa c√≥mo cambia la activaci√≥n frente a un borde horizontal.

üîç ¬øQu√© ocurre si el centro est√° alineado con el borde?  
üîç ¬øQu√© pasa si el campo es sim√©trico o invertido?

Este ejercicio simula c√≥mo las c√©lulas ganglionares detectan bordes mediante antagonismo centro-periferia, y c√≥mo este principio se aplica en redes convolucionales en visi√≥n artificial.

"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
from IPython.display import HTML

# Est√≠mulo visual: borde horizontal
imagen = np.zeros((10,10))
imagen[5:] = 1  # mitad inferior brillante

# Campo receptivo circular ON u OFF
def construir_campo_circular(polaridad='ON', radio_centro=1.0, radio_periferia=2.0, peso_centro=6, peso_periferia=-1):
    campo = np.zeros((5,5))
    for i in range(5):
        for j in range(5):
            distancia = np.sqrt((i-2)**2 + (j-2)**2)
            if distancia < radio_centro:
                campo[i,j] = peso_centro
            elif distancia < radio_periferia:
                campo[i,j] = peso_periferia
    if polaridad == 'OFF':
        campo *= -1
    return campo

# Par√°metros ajustables
radio_centro = 1.0
radio_periferia = 2.0
peso_centro = 6
peso_periferia = -1

campo_on = construir_campo_circular('ON', radio_centro, radio_periferia, peso_centro, peso_periferia)
campo_off = construir_campo_circular('OFF', radio_centro, radio_periferia, peso_centro, peso_periferia)

# Aplicar campo en posici√≥n (fila, col)
def aplicar_en_posicion(imagen, campo, fila, col):
    subimagen = imagen[fila:fila+5, col:col+5]
    producto = subimagen * campo
    activacion = np.sum(producto)
    return producto, activacion

# Crear figura
fig, axs = plt.subplots(2, 3, figsize=(20,10))

def init():
    for ax in axs.flat:
        ax.clear()

def animate(frame):
    fila = frame
    col = 2

    for ax in axs.flat:
        ax.clear()

    producto_on, act_on = aplicar_en_posicion(imagen, campo_on, fila, col)
    producto_off, act_off = aplicar_en_posicion(imagen, campo_off, fila, col)

    # Est√≠mulo visual
    axs[0,0].imshow(imagen, cmap='gray')
    axs[0,0].axhline(4.5, color='red', linestyle='--', linewidth=2)
    axs[0,0].add_patch(plt.Rectangle((col,fila),5,5,fill=False,edgecolor='blue',linewidth=2))
    axs[0,0].set_title(f"Est√≠mulo visual\nCampo en ({fila},{col})")
    axs[0,0].axis('off')

    # Campo ON aplicado
    axs[0,1].imshow(producto_on, cmap='coolwarm', vmin=-6, vmax=6)
    axs[0,1].set_title("ON: Subimagen √ó Campo")
    for i in range(5):
        for j in range(5):
            val = producto_on[i,j]
            axs[0,1].text(j, i, f"{val:.1f}", ha='center', va='center', color='black', fontsize=8)
    axs[0,1].grid(True)

    # Activaci√≥n ON
    axs[0,2].bar([0], [act_on], color='limegreen')
    axs[0,2].axhline(0, color='black', linestyle='--')
    axs[0,2].set_ylim(act_on - 10, act_on + 10)
    axs[0,2].set_title(f"Activaci√≥n ON: {act_on:.1f}")
    axs[0,2].set_xticks([])
    axs[0,2].grid(True)

    # Campo OFF aplicado
    axs[1,1].imshow(producto_off, cmap='coolwarm', vmin=-6, vmax=6)
    axs[1,1].set_title("OFF: Subimagen √ó Campo")
    for i in range(5):
        for j in range(5):
            val = producto_off[i,j]
            axs[1,1].text(j, i, f"{val:.1f}", ha='center', va='center', color='black', fontsize=8)
    axs[1,1].grid(True)

    # Activaci√≥n OFF
    axs[1,2].bar([0], [act_off], color='orange')
    axs[1,2].axhline(0, color='black', linestyle='--')
    axs[1,2].set_ylim(act_off - 10, act_off + 10)
    axs[1,2].set_title(f"Activaci√≥n OFF: {act_off:.1f}")
    axs[1,2].set_xticks([])
    axs[1,2].grid(True)

    # Est√≠mulo duplicado abajo
    axs[1,0].imshow(imagen, cmap='gray')
    axs[1,0].axhline(4.5, color='red', linestyle='--', linewidth=2)
    axs[1,0].add_patch(plt.Rectangle((col,fila),5,5,fill=False,edgecolor='blue',linewidth=2))
    axs[1,0].set_title(f"Est√≠mulo visual\nCampo en ({fila},{col})")
    axs[1,0].axis('off')

    plt.tight_layout()

ani = animation.FuncAnimation(fig, animate, frames=6, init_func=init, interval=1200, repeat=False)
HTML(ani.to_jshtml())

"""### üß† Comparaci√≥n ON vs OFF con radio funcional ajustable

Esta animaci√≥n permite comparar c√≥mo responden los campos ganglionares ON y OFF al desplazarse sobre un borde horizontal.

- Ambos campos tienen arquitectura circular, con centro activador y periferia inhibidora.
- Se visualiza la multiplicaci√≥n subimagen √ó campo y la activaci√≥n total.
- Puedes modificar el radio funcional para explorar sensibilidad espacial.

üîç ¬øQu√© tipo de campo responde mejor al borde?  
üîç ¬øC√≥mo cambia la activaci√≥n si el centro o la periferia se expanden?

"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
from IPython.display import HTML

# Est√≠mulo visual: borde horizontal
imagen = np.zeros((10,10))
imagen[5:] = 1  # mitad inferior brillante

# Campo receptivo circular ON con centro fuerte
def construir_campo_circular():
    campo = np.zeros((5,5))
    for i in range(5):
        for j in range(5):
            distancia = np.sqrt((i-2)**2 + (j-2)**2)
            if distancia < 1.0:
                campo[i,j] = 6  # centro activador
            elif distancia < 2.0:
                campo[i,j] = -1  # periferia inhibidora
    return campo

campo = construir_campo_circular()

# Aplicar campo en posici√≥n (fila, col)
def aplicar_en_posicion(imagen, campo, fila, col):
    subimagen = imagen[fila:fila+5, col:col+5]
    producto = subimagen * campo
    activacion = np.sum(producto)
    return subimagen, producto, activacion

# Crear figura
fig, axs = plt.subplots(1, 3, figsize=(20,6))

def init():
    for ax in axs:
        ax.clear()

def animate(frame):
    fila = frame  # desplazamiento vertical
    col = 2       # posici√≥n horizontal fija

    for ax in axs:
        ax.clear()

    subimg, producto, act = aplicar_en_posicion(imagen, campo, fila, col)

    # Panel 1: Est√≠mulo con borde marcado
    axs[0].imshow(imagen, cmap='gray')
    axs[0].axhline(4.5, color='red', linestyle='--', linewidth=2)  # borde marcado
    axs[0].add_patch(plt.Rectangle((col,fila),5,5,fill=False,edgecolor='blue',linewidth=2))
    axs[0].set_title(f"Est√≠mulo visual\nCampo en ({fila},{col})")
    axs[0].axis('off')

    # Panel 2: Campo receptivo circular
    axs[1].imshow(campo, cmap='bwr', vmin=-6, vmax=6)
    axs[1].set_title("Campo receptivo circular")
    for i in range(5):
        for j in range(5):
            val = campo[i,j]
            axs[1].text(j, i, f"{val:.0f}", ha='center', va='center', color='black', fontsize=8)
    circ = plt.Circle((2,2), 2.0, color='black', fill=False, linestyle='--', linewidth=1)
    axs[1].add_patch(circ)
    axs[1].grid(True)
    axs[1].set_xticks(np.arange(-0.5, 5, 1))
    axs[1].set_yticks(np.arange(-0.5, 5, 1))
    axs[1].set_xticklabels([])
    axs[1].set_yticklabels([])
    axs[1].set_xlim(-0.5, 4.5)
    axs[1].set_ylim(-0.5, 4.5)

    # Panel 3: Activaci√≥n con l√≠nea base
    axs[2].bar([0], [act], color='limegreen')
    axs[2].axhline(0, color='black', linestyle='--')  # l√≠nea base
    axs[2].set_ylim(act - 10, act + 10)
    axs[2].set_title(f"Activaci√≥n total: {act:.1f}")
    axs[2].set_xticks([])
    axs[2].grid(True)

    plt.tight_layout()

ani = animation.FuncAnimation(fig, animate, frames=6, init_func=init, interval=1200, repeat=False)
HTML(ani.to_jshtml())

"""**El cuadrado azul permite visualizar:**

D√≥nde est√° ‚Äúmirando‚Äù la c√©lula ganglionar en cada momento.

Si el centro del campo cae sobre zona clara y la periferia sobre zona oscura ‚Üí activaci√≥n positiva.

Si todo el campo cae sobre zona clara ‚Üí inhibici√≥n (activaci√≥n negativa).

Si todo el campo cae sobre zona oscura ‚Üí activaci√≥n baja o nula.
"""

# Paso 1: Cargar imagen desde URL
import matplotlib.pyplot as plt
import numpy as np
import requests
from PIL import Image
from io import BytesIO
from scipy.signal import convolve2d
import cv2

from google.colab import files
uploaded = files.upload()

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

img = Image.open("Tigre_tronco.png").convert("L")  # escala de grises
img_array = np.array(img)

plt.imshow(img_array, cmap='gray')
plt.title("Imagen cargada")
plt.axis('off')
plt.show()


# Paso 2: Convertir a escala de grises
img_gray = img.convert("L")
img_array = np.array(img_gray)

# Paso 3: Definir filtros ON y OFF (tipo centro-periferia)
def filtro_on():
    f = np.full((5,5), -1)
    f[2,2] = 8
    return f

def filtro_off():
    f = np.full((5,5), 1)
    f[2,2] = -8
    return f

# Paso 4: Aplicar convoluciones
activacion_on = convolve2d(img_array, filtro_on(), mode='same', boundary='symm')
activacion_off = convolve2d(img_array, filtro_off(), mode='same', boundary='symm')

# Paso 5: Visualizar resultados
fig, axs = plt.subplots(1, 3, figsize=(18,6))

axs[0].imshow(img_array, cmap='gray')
axs[0].set_title("Imagen original (escala de grises)")
axs[0].axis('off')

axs[1].imshow(activacion_on, cmap='hot')
axs[1].set_title("Activaci√≥n ON (zonas claras)")
axs[1].axis('off')

axs[2].imshow(activacion_off, cmap='bone')
axs[2].set_title("Activaci√≥n OFF (zonas oscuras)")
axs[2].axis('off')

plt.tight_layout()
plt.show()

"""### üß† Activaci√≥n ON/OFF sobre imagen natural

Este ejercicio simula c√≥mo las c√©lulas ganglionares ON y OFF responden a una escena visual real.  
- El filtro ON detecta zonas brillantes rodeadas de oscuridad.  
- El filtro OFF detecta zonas oscuras rodeadas de luz.  

üîç ¬øQu√© zonas del tigre activan m√°s cada tipo de c√©lula?  
üîç ¬øC√≥mo se relaciona esto con la detecci√≥n de bordes y camuflaje?

"""

import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import clear_output

# Generador de est√≠mulos
def generar_estimulo(tipo):
    matriz = np.zeros((5,5))
    if tipo == "centro_brillante":
        matriz[2,2] = 1
    elif tipo == "centro_oscuro":
        matriz = np.ones((5,5))
        matriz[2,2] = 0
    elif tipo == "periferia_brillante":
        matriz = np.ones((5,5))
        matriz[2,2] = 0
    elif tipo == "periferia_oscura":
        matriz = np.zeros((5,5))
        matriz[2,2] = 1
    elif tipo == "uniforme_brillante":
        matriz = np.ones((5,5))
    elif tipo == "uniforme_oscuro":
        matriz = np.zeros((5,5))
    return matriz

# Modelos de respuesta
def respuesta_bipolar(matriz, tipo):
    centro = matriz[2,2]
    return centro if tipo == "ON" else 1 - centro

def respuesta_ganglionar(matriz, tipo):
    centro = matriz[2,2]
    periferia = np.mean(np.delete(matriz.flatten(), 12))
    return centro - periferia if tipo == "ON" else periferia - centro

# Campo receptivo esquem√°tico
def generar_campo_receptivo(tipo_celula):
    receptivo = np.zeros((5,5))
    centro = (2,2)
    for i in range(5):
        for j in range(5):
            if (i,j) == centro:
                receptivo[i,j] = 1 if tipo_celula == "ON" else -1
            else:
                receptivo[i,j] = -1 if tipo_celula == "ON" else 1
    return receptivo

# Visualizaci√≥n completa
def visualizar_comparativo(tipo):
    clear_output(wait=True)
    matriz = generar_estimulo(tipo)
    respuestas = {
        "Bipolar ON": respuesta_bipolar(matriz, "ON"),
        "Bipolar OFF": respuesta_bipolar(matriz, "OFF"),
        "Ganglionar ON": respuesta_ganglionar(matriz, "ON"),
        "Ganglionar OFF": respuesta_ganglionar(matriz, "OFF")
    }

    fig, axs = plt.subplots(1, 4, figsize=(22,5))

    # Est√≠mulo visual
    axs[0].imshow(matriz, cmap='gray')
    axs[0].set_title(f"Est√≠mulo aplicado: {tipo.replace('_',' ')}")
    axs[0].axis('off')

    # Respuesta celular
    axs[1].bar(respuestas.keys(), respuestas.values(), color=['skyblue','salmon','limegreen','orange'])
    axs[1].set_title("Activaci√≥n celular")
    axs[1].set_ylim(-1,1)
    axs[1].grid(True)

    # Campo receptivo ON
    receptivo_on = generar_campo_receptivo("ON")
    im1 = axs[2].imshow(receptivo_on, cmap='bwr', vmin=-1, vmax=1)
    axs[2].set_title("Campo receptivo ganglionar ON")
    axs[2].axis('off')
    fig.colorbar(im1, ax=axs[2], orientation='vertical')

    # Campo receptivo OFF
    receptivo_off = generar_campo_receptivo("OFF")
    im2 = axs[3].imshow(receptivo_off, cmap='bwr', vmin=-1, vmax=1)
    axs[3].set_title("Campo receptivo ganglionar OFF")
    axs[3].axis('off')
    fig.colorbar(im2, ax=axs[3], orientation='vertical')

    plt.tight_layout()
    plt.show()

# Widget interactivo
selector = widgets.Dropdown(
    options=["centro_brillante", "centro_oscuro", "periferia_brillante", "periferia_oscura", "uniforme_brillante", "uniforme_oscuro"],
    description='Est√≠mulo:',
)

widgets.interact(visualizar_comparativo, tipo=selector)